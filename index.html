<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>B·∫£n ƒë·ªì FTTH ‚Äì Hi·ªáu su·∫•t port GPON</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
  body { margin:0; font-family: Arial, sans-serif; }
  #map { height: 100vh; }
  .control-panel {
    position: absolute;
    top: 10px;
    left: 10px;
    background: #fff;
    padding: 10px;
    z-index: 1000;
    width: 300px;
    box-shadow: 0 0 5px rgba(0,0,0,0.3);
  }
  .legend div { margin-bottom: 4px; }
  .blink {
    animation: blink 1s infinite;
  }
  @keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.2; }
    100% { opacity: 1; }
  }
</style>
</head>

<body>

<div class="control-panel">
  <b>üîç T√¨m ki·∫øm</b><br>
  <input id="searchInput" placeholder="ƒê·ªãa ch·ªâ ho·∫∑c lat,lng" style="width:100%">
  <button onclick="searchLocation()">T√¨m</button>

  <hr>

  <b>üéö Filter hi·ªáu su·∫•t</b><br>
  <select id="usageFilter" onchange="applyFilter()">
    <option value="all">T·∫•t c·∫£</option>
    <option value="<20">&lt; 20%</option>
    <option value="20-50">20 ‚Äì 50%</option>
    <option value="50-80">50 ‚Äì 80%</option>
    <option value=">=80">‚â• 80%</option>
  </select>

  <hr>

  <button onclick="exportUpgradeCSV()">
    Danh s√°ch t·∫≠p ƒëi·ªÉm c·∫ßn n√¢ng c·∫•p
  </button>

  <hr>

  <b>üé® Legend</b>
  <div class="legend">
    <div style="color:blue">‚óè &lt;20%</div>
    <div style="color:green">‚óè 20‚Äì50%</div>
    <div style="color:orange">‚óè 50‚Äì80%</div>
    <div style="color:red">‚óè 80‚Äì100%</div>
    <div style="color:black">‚óè ‚â•100%</div>
  </div>
</div>

<div id="map"></div>

<!-- Lib -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://www.gstatic.com/charts/loader.js"></script>

<script>
/* ===================== CONFIG ===================== */
const SHEET_ID = "1avvicsQgJIm_D66EsPxFE7aUBCfuMdBq";
const SHEET_NAME = "Danh s√°ch t·∫≠p ƒëi·ªÉm S2";

/* ===================== GLOBAL ===================== */
let map;
let allPoints = [];
let circles = [];
let customerMarker;
let suggestLines = [];

/* ===================== INIT MAP ===================== */
map = L.map('map').setView([16, 108], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

/* ===================== LOAD GOOGLE SHEET ===================== */
google.charts.load('current', { packages: ['corechart'] });
google.charts.setOnLoadCallback(loadDataFromSheet);

function loadDataFromSheet() {
  const query = new google.visualization.Query(
    `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?sheet=${encodeURIComponent(SHEET_NAME)}`
  );
  query.send(handleSheetResponse);
}

function handleSheetResponse(response) {
  const data = response.getDataTable();
  for (let i = 0; i < data.getNumberOfRows(); i++) {
    const lat = Number(data.getValue(i, 9));
    const lng = Number(data.getValue(i, 10));
    if (!isValidLatLng(lat, lng)) continue;

    allPoints.push({
      name: data.getValue(i, 2),
      maxPort: data.getValue(i, 3),
      usedPort: data.getValue(i, 4),
      freePort: data.getValue(i, 5),
      usage: Number(data.getValue(i, 7)) * 100,
      lat, lng
    });
  }
  drawMapPoints(allPoints);
}

/* ===================== VALIDATE ===================== */
function isValidLatLng(lat, lng) {
  return (
    typeof lat === "number" &&
    typeof lng === "number" &&
    !isNaN(lat) &&
    !isNaN(lng) &&
    lat >= -90 && lat <= 90 &&
    lng >= -180 && lng <= 180
  );
}

/* ===================== DRAW MAP ===================== */
function getColorByUsage(u) {
  if (u >= 100) return "black";
  if (u >= 80) return "red";
  if (u >= 50) return "orange";
  if (u >= 20) return "green";
  return "blue";
}

function drawMapPoints(points) {
  circles.forEach(c => map.removeLayer(c));
  circles = [];
  const bounds = [];

  points.forEach(p => {
    const circle = L.circle([p.lat, p.lng], {
      radius: 300,
      color: getColorByUsage(p.usage),
      fillColor: getColorByUsage(p.usage),
      fillOpacity: 0.5,
      weight: 2
    }).addTo(map);

    circle.bindPopup(`
      <b>${p.name}</b><br>
      Dung l∆∞·ª£ng: ${p.maxPort}<br>
      ƒê√£ d√πng: ${p.usedPort}<br>
      C√≤n l·∫°i: ${p.freePort}<br>
      Hi·ªáu su·∫•t: ${p.usage.toFixed(1)}%
    `);

    circle.__data = p;
    circles.push(circle);
    bounds.push([p.lat, p.lng]);
  });

  if (bounds.length) map.fitBounds(bounds);
}

/* ===================== FILTER ===================== */
function applyFilter() {
  const f = document.getElementById("usageFilter").value;
  const filtered = allPoints.filter(p => {
    if (f === "all") return true;
    if (f === "<20") return p.usage < 20;
    if (f === "20-50") return p.usage >= 20 && p.usage < 50;
    if (f === "50-80") return p.usage >= 50 && p.usage < 80;
    if (f === ">=80") return p.usage >= 80;
  });
  drawMapPoints(filtered);
}

/* ===================== SEARCH ===================== */
function searchLocation() {
  const q = document.getElementById("searchInput").value.trim();
  if (!q) return;

  if (q.includes(",")) {
    const [lat, lng] = q.split(",").map(Number);
    focusCustomer(lat, lng);
  } else {
    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`)
      .then(r => r.json())
      .then(r => {
        if (r.length) focusCustomer(Number(r[0].lat), Number(r[0].lon));
      });
  }
}

function focusCustomer(lat, lng) {
  if (!isValidLatLng(lat, lng)) return;
  if (customerMarker) map.removeLayer(customerMarker);
  customerMarker = L.marker([lat, lng]).addTo(map);
  map.setView([lat, lng], 16);
  suggestNearest(lat, lng);
}

/* ===================== SUGGEST ===================== */
function haversine(a, b) {
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLng = (b.lng - a.lng) * Math.PI / 180;
  const x = Math.sin(dLat/2)**2 +
            Math.cos(a.lat*Math.PI/180) *
            Math.cos(b.lat*Math.PI/180) *
            Math.sin(dLng/2)**2;
  return 2 * R * Math.asin(Math.sqrt(x));
}

function suggestNearest(lat, lng) {
  suggestLines.forEach(l => map.removeLayer(l));
  suggestLines = [];

  const customer = { lat, lng };
  const candidates = allPoints
    .filter(p => p.freePort > 0)
    .map(p => ({ ...p, dist: haversine(customer, p) }))
    .sort((a,b) => a.dist - b.dist || a.usage - b.usage)
    .slice(0,3);

  candidates.forEach((p, idx) => {
    const line = L.polyline([[lat,lng],[p.lat,p.lng]], {
      color: "green",
      dashArray: "5,5"
    }).addTo(map);
    line.bindTooltip(`${Math.round(p.dist)} m`);
    suggestLines.push(line);

    const c = circles.find(c => c.__data === p);
    if (c) {
      c.setStyle({ weight: 5 });
      c.getElement().classList.add("blink");
    }
  });
}

/* ===================== EXPORT ===================== */
function exportUpgradeCSV() {
  let csv = "T√™n t·∫≠p ƒëi·ªÉm,Latitude,Longitude,Hi·ªáu su·∫•t (%),M·ª©c ∆∞u ti√™n\n";
  allPoints.filter(p => p.usage >= 80).forEach(p => {
    const pr = p.usage >= 100 ? "∆Øu ti√™n 1" : "∆Øu ti√™n 2";
    csv += `${p.name},${p.lat},${p.lng},${p.usage.toFixed(1)},${pr}\n`;
  });

  const blob = new Blob([csv], { type: "text/csv" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "tap_diem_can_nang_cap.csv";
  a.click();
}
</script>

</body>
</html>
