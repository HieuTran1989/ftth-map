<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>B·∫£n ƒë·ªì hi·ªáu su·∫•t t·∫≠p ƒëi·ªÉm FTTH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Google Visualization -->
  <script src="https://www.gstatic.com/charts/loader.js"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    #map {
      width: 100%;
      height: 100%;
    }

    .control-box {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.3);
      font-size: 13px;
    }

    .legend {
      margin-top: 6px;
    }

    .legend div {
      margin-bottom: 4px;
    }

    .blink {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>

<div class="control-box">
  <div>
    <input id="searchInput" placeholder="ƒê·ªãa ch·ªâ ho·∫∑c lat,lng" style="width:200px">
    <button onclick="searchLocation()">T√¨m</button>
  </div>

  <div style="margin-top:6px">
    <select id="filterSelect" onchange="applyFilter()">
      <option value="all">T·∫•t c·∫£</option>
      <option value="lt20">&lt; 20%</option>
      <option value="20_50">20‚Äì50%</option>
      <option value="50_80">50‚Äì80%</option>
      <option value="gte80">&ge; 80%</option>
    </select>
  </div>

  <div class="legend">
    <div>üîµ &lt;20%</div>
    <div>üü¢ 20‚Äì50%</div>
    <div>üü° 50‚Äì80%</div>
    <div>üî¥ 80‚Äì&lt;100%</div>
    <div>‚ö´ ‚â•100%</div>
  </div>

  <div style="margin-top:6px">
    <button onclick="exportUpgradeList()">Danh s√°ch t·∫≠p ƒëi·ªÉm c·∫ßn n√¢ng c·∫•p</button>
  </div>
</div>

<div id="map"></div>

<script>
/* ==========================
   GLOBAL
========================== */

const SHEET_URL = 'https://docs.google.com/spreadsheets/d/1avvicsQgJIm_D66EsPxFE7aUBCfuMdBq';
const SHEET_NAME = 'Danh s√°ch t·∫≠p ƒëi·ªÉm S2';

let map;
let allPoints = [];
let customerMarker = null;
let suggestionLayers = [];

let isInitialLoad = true; // üîë CH·ªà D√ôNG CHO AUTO ZOOM BAN ƒê·∫¶U

/* ==========================
   INIT MAP
========================== */

map = L.map('map').setView([10.8, 106.7], 11);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19
}).addTo(map);

/* ==========================
   UTILS
========================== */

function validateLatLng(lat, lng) {
  return (
    lat !== null &&
    lng !== null &&
    !isNaN(lat) &&
    !isNaN(lng) &&
    lat >= -90 && lat <= 90 &&
    lng >= -180 && lng <= 180
  );
}

function getColor(eff) {
  if (eff < 0.2) return 'blue';
  if (eff < 0.5) return 'green';
  if (eff < 0.8) return 'yellow';
  if (eff < 1) return 'red';
  return 'black';
}

function haversine(lat1, lng1, lat2, lng2) {
  const R = 6371000;
  const toRad = d => d * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLng = toRad(lng2 - lng1);

  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(toRad(lat1)) *
    Math.cos(toRad(lat2)) *
    Math.sin(dLng/2)**2;

  return 2 * R * Math.asin(Math.sqrt(a));
}

/* ==========================
   LOAD DATA
========================== */

google.charts.load('current', { packages: ['corechart'] });
google.charts.setOnLoadCallback(loadData);

function loadData() {
  const query = new google.visualization.Query(
    `${SHEET_URL}/gviz/tq?sheet=${encodeURIComponent(SHEET_NAME)}`
  );

  query.send(res => {
    const data = res.getDataTable();
    for (let i = 0; i < data.getNumberOfRows(); i++) {
      const lat = Number(data.getValue(i, 9));
      const lng = Number(data.getValue(i, 10));

      if (!validateLatLng(lat, lng)) continue;

      const eff = Number(data.getValue(i, 7));

      const point = {
        name: data.getValue(i, 2),
        maxPort: data.getValue(i, 3),
        usedPort: data.getValue(i, 4),
        freePort: data.getValue(i, 5),
        eff,
        lat, lng,
        valid: true,
        circle: null
      };

      const circle = L.circle([lat, lng], {
        radius: 300,
        color: getColor(eff),
        fillColor: getColor(eff),
        fillOpacity: 0.5,
        weight: 2
      });

      circle.bindPopup(`
        <b>${point.name}</b><br>
        Dung l∆∞·ª£ng: ${point.maxPort}<br>
        ƒê√£ d√πng: ${point.usedPort}<br>
        C√≤n l·∫°i: ${point.freePort}<br>
        Hi·ªáu su·∫•t: ${(eff * 100).toFixed(1)}%
      `);

      point.circle = circle;
      allPoints.push(point);
    }

    renderPoints();
  });
}

/* ==========================
   RENDER POINTS
========================== */

function renderPoints() {
  const boundsLatLng = [];

  allPoints.forEach(p => {
    p.circle.addTo(map);
    boundsLatLng.push([p.lat, p.lng]);
  });

  // ‚úÖ AUTO ZOOM CH·ªà 1 L·∫¶N DUY NH·∫§T
  if (isInitialLoad && boundsLatLng.length) {
    map.fitBounds(boundsLatLng, { padding: [40, 40] });
    isInitialLoad = false;
  }
}

/* ==========================
   FILTER (KH√îNG ƒê·ª§NG VIEW)
========================== */

function applyFilter() {
  const val = document.getElementById('filterSelect').value;

  allPoints.forEach(p => {
    let show = true;

    if (val === 'lt20') show = p.eff < 0.2;
    else if (val === '20_50') show = p.eff >= 0.2 && p.eff < 0.5;
    else if (val === '50_80') show = p.eff >= 0.5 && p.eff < 0.8;
    else if (val === 'gte80') show = p.eff >= 0.8;

    if (show) {
      p.circle.addTo(map);
    } else {
      map.removeLayer(p.circle);
    }
  });
}

/* ==========================
   SEARCH (GI·ªÆ NGUY√äN)
========================== */

function searchLocation() {
  const val = document.getElementById('searchInput').value.trim();
  if (!val) return;

  const parts = val.split(',');
  if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
    handleCustomer(Number(parts[0]), Number(parts[1]));
    return;
  }

  fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}`)
    .then(r => r.json())
    .then(res => {
      if (!res.length) return;
      handleCustomer(Number(res[0].lat), Number(res[0].lon));
    });
}

/* ==========================
   CUSTOMER & SUGGEST
========================== */

function handleCustomer(lat, lng) {
  if (customerMarker) map.removeLayer(customerMarker);
  suggestionLayers.forEach(l => map.removeLayer(l));
  suggestionLayers = [];

  customerMarker = L.marker([lat, lng]).addTo(map);
  map.setView([lat, lng], 15);

  const candidates = allPoints
    .filter(p => p.freePort > 0)
    .map(p => ({
      ...p,
      dist: haversine(lat, lng, p.lat, p.lng)
    }))
    .sort((a, b) => a.dist - b.dist || a.eff - b.eff)
    .slice(0, 3);

  candidates.forEach((p, idx) => {
    p.circle.getElement().classList.add('blink');
    p.circle.setStyle({ weight: 4 });

    const line = L.polyline([[lat, lng], [p.lat, p.lng]], {
      color: 'green',
      dashArray: '5,5'
    }).addTo(map);

    line.bindTooltip(`${Math.round(p.dist)} m`);

    p.circle.bindPopup(`
      <b>${p.name}</b><br>
      Dung l∆∞·ª£ng: ${p.maxPort}<br>
      ƒê√£ d√πng: ${p.usedPort}<br>
      C√≤n l·∫°i: ${p.freePort}<br>
      Hi·ªáu su·∫•t: ${(p.eff * 100).toFixed(1)}%<br>
      Kho·∫£ng c√°ch: ${Math.round(p.dist)} m<br>
      ${idx === 0 ? '<b>‚≠ê T·∫¨P ƒêI·ªÇM T·ªêT NH·∫§T</b>' : ''}
    `);

    suggestionLayers.push(line);
  });
}

/* ==========================
   EXPORT EXCEL
========================== */

function exportUpgradeList() {
  const rows = [
    ['T√™n t·∫≠p ƒëi·ªÉm', 'Latitude', 'Longitude', 'Hi·ªáu su·∫•t (%)', 'M·ª©c ∆∞u ti√™n']
  ];

  allPoints.forEach(p => {
    if (p.eff >= 0.8) {
      rows.push([
        p.name,
        p.lat,
        p.lng,
        (p.eff * 100).toFixed(1),
        p.eff >= 1 ? '∆Øu ti√™n 1' : '∆Øu ti√™n 2'
      ]);
    }
  });

  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(rows);
  XLSX.utils.book_append_sheet(wb, ws, 'Nang cap');
  XLSX.writeFile(wb, 'tap_diem_can_nang_cap.xlsx');
}
</script>

</body>
</html>
